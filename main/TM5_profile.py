'''
Extract trace gas profile(s) from a CTMANA file for netcdf file generated by s5p_lnox_main.py 

Modified from PyCAMA:
        https://dev.knmi.nl/projects/pycama/repository/entry/src/TM5_profile.py

NOTE:
1. Please feel free to download CTMANA using `pytropomi`(https://github.com/bugsuse/pytropomi/issues), e.g.
    ```
    from datetime import datetime
    from pytropomi.downs5p import downs5p
    beginPosition = datetime(2019, 6, 20, 0)
    endPosition = datetime(2019, 6, 21, 0)
    pro = 'AUX_CTMANA'
    downs5p(producttype=pro, beginPosition=beginPosition, endPosition=endPosition)
    ```
    Xin has also written a script (`download_ctmana.py`) to download files by reading dates file.

2. Because the global CTMANA file is so large (~ 1.5G), it's better to use nco to subset it:
    ncea -d lat,65,90 -d lon,-179.5,179.5 -v lon,lat,hyai,hybi,hyam,hybm,lev,time,date,ps,tropopause_layer_index,t,no2 <original_file>.nc <subset>.nc

    For subsetting all files, you can write a bash script:
    ```
    #!/bin/bash

    mkdir -p ./subset

    for file in ./*.nc; do
        echo $file
        ncea -d lat,65,90 -d lon,-179.5,179.5 -v lon,lat,hyai,hybi,hyam,hybm,lev,time,date,ps,tropopause_layer_index,t,no2 $file ./subset/$file
    done
    ```

'''

import os
import sys
import netCDF4
import datetime
import numpy as np
from scipy import constants
from numba import jit

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)


@jit(nopython=True)
def calc_field(weights, spatial_index_lat, spatial_index_lon,
               surface_pressure_external, surface_pressure, field,
               result_field, result_pressure, hya, hyb):
    for pix_idx in range(weights.shape[1]):
        if surface_pressure_external is not None:
            ps = surface_pressure_external.flat[pix_idx]
        else:
            ps = 0.0
        for i in range(4):
            if surface_pressure_external is None:
                ps += (weights[i, pix_idx] * 
                        surface_pressure[spatial_index_lat[i, pix_idx], 
                                         spatial_index_lon[i, pix_idx]])
            result_field[:, pix_idx] += (weights[i, pix_idx] * 
                                         field[:, spatial_index_lat[i, pix_idx], 
                                         spatial_index_lon[i, pix_idx]])
        
        result_pressure[:, pix_idx] = hya + ps * hyb

    return result_field, result_pressure

class CTM:
    def __init__(self, fname:str, species:str='no2'):
        self.fname = fname
        self.slice_index = None
        self.weights = None
        self.spatial_index_lon = None
        self.spatial_index_lat = None
        self.species = species
        self.final_output_shape = None
        self.ref = None
    
    def __enter__(self): 
        self.ref = netCDF4.Dataset(self.fname, 'r')
        return self.ref
  
    def __exit__(self, exception_type, exception_value, traceback): 
        if self.ref is not None:
            self.ref.close()
            self.ref = None
    
    def close(self):
        self.__exit__(None, None, None)
    
    def find_slice(self, t: datetime.datetime) -> int:
        """Find the correct time index"""
        time_ref = self.ref["time"]
        times = time_ref[:]
        time_units = time_ref.units
        
        try:
            f_times = netCDF4.num2date(times, time_units, 
                        only_use_cftime_datetimes=False, 
                        only_use_python_datetimes=True)
        except TypeError:
            f_times = netCDF4.num2date(times, time_units)
        
        quarter = datetime.timedelta(minutes=15)
        second  = datetime.timedelta(seconds=1)
        extra = quarter - second

        if t < f_times[0] - extra or t > f_times[-1] + extra:
            raise RuntimeError("Requested time not covered in CTM file.")
        else:
            self.slice_index = np.argmin([np.fabs((t - tt).total_seconds()) for tt in f_times])
        self.slice_time = f_times[self.slice_index]
        return self.slice_index,self.slice_time
        
    def find_indices_weights(self, latitude, longitude):
        """Find indices and weights for the spatial interpolation

Result applies to flattened array
"""
        if isinstance(latitude, list):
            latitude = np.asarray(latitude, dtype=np.float64)
            longitude = np.asarray(longitude, dtype=np.float64)
        elif isinstance(latitude, (int, float)):
            latitude = np.asarray([latitude], dtype=np.float64)
            longitude = np.asarray([longitude], dtype=np.float64)
        
        if np.any(latitude > 90.0) or np.any(latitude < -90.0):
            raise RuntimeError("Latitude out of bounds")
        if np.prod(latitude.shape) != np.prod(longitude.shape):
            raise RuntimeError("Size of latitude and longitude must match")
        
        self.final_output_shape = list(self.ref['hyam'].shape)
        self.final_output_shape.extend(list(latitude.shape))
        
        latitude = latitude.flatten()
        longitude = longitude.flatten()
        
        # size of TM5 array
        jm, im = self.ref[self.species].shape[-2:]
        
        longitude = np.where(longitude < -180.0, longitude + 360.0, longitude)
        longitude = np.where(longitude >= 180.0, longitude - 360.0, longitude)
        dlon = 360.0/im
        firstcellmid = 0.5*dlon-180.0
        rx = (longitude-firstcellmid)/dlon
        ix = np.asarray(rx, dtype=np.int32)
        gdx = rx - ix
        ix = np.where(ix == im, 0, ix)
        
        dlat = 180.0/jm
        firstcellmid = 0.5*dlat-90.0
        ry = (latitude-firstcellmid)/dlat
        iy = np.asarray(ry, dtype=np.int32)
        gdy = ry - iy
        
        # the other corner
        ix2 = ix + 1
        ix2 = np.where(ix2 == im, 0, ix2)
        iy2 = iy + 1
        if np.any(iy2 >= jm):
            idy = iy2 >= jm
            iy[idy] = jm-2
            iy2[idy] = jm-1
            gdy[idy] = 1.0
        if np.any(iy < 0):
            idy = iy < 0
            iy[idy] = 0
            iy2[idy] = 1
            gdy[idy] = 1.0
        
        output_shape = [4]
        output_shape.extend(list(latitude.shape))
        output_shape = tuple(output_shape)
        ix4a = np.concatenate((ix, ix2, ix, ix2)).reshape(output_shape)
        iy4a = np.concatenate((iy, iy, iy2, iy2)).reshape(output_shape)
        w4a = np.concatenate(((1-gdx)*(1-gdy), gdx*(1-gdy), (1-gdx)*gdy, gdx*gdy)).reshape(output_shape)
        
        self.weights = w4a
        self.spatial_index_lon = ix4a
        self.spatial_index_lat = iy4a

        return ix4a, iy4a, w4a
    
    def get_pressures_interfaces(self):
        """Get pressure at the interfaces of the model"""
        field = self.ref[self.species]
        pressure_shape = list(field.shape[1:])
        pressure_shape[0] += 1
        p_interfaces = np.zeros(pressure_shape, dtype=np.float32)
        ps = self.ref['ps'][self.slice_index, ...]
        hyai = self.ref['hyai'][:]
        hybi = self.ref['hybi'][:]
        
        for i, (a, b) in enumerate(zip(hyai, hybi)):
            p_interfaces[i, ...] = a + b*ps
            
        return p_interfaces

    def get_partial_column_field(self, p_interfaces=None):
        """Translate input field in volume mixing ratio to mol/m?? per layer"""
        xmair = 28.94 # mass of air (gram/mol)
        # conversion factor from mixing ratio, pressure drop (in Pa) to columns (in 10^15 molec cm^-2)
        pdiff2moleccm2 = 1.0e-15 * 0.1 * constants.Avogadro/(constants.g * xmair)
        # conversion factor from mixing ratio, pressure drop (in Pa) to columns in mol/m2.
        pdiffmolm2 =  1000 /(constants.g * xmair)
        
        field = self.ref[self.species]
        ps = self.ref['ps']
        hyai = self.ref['hyai'][:]
        hybi = self.ref['hybi'][:]
        
        # partial columns
        partial_column_field = np.zeros(field.shape[1:], dtype=np.float32)
        if p_interfaces is None:
            p_interfaces = self.get_pressures_interfaces()
        
        for level in range(self.ref[self.species].shape[1]):
            dp = p_interfaces[level, ...] - p_interfaces[level+1, ...]
            partial_column_field[level, ...] = pdiffmolm2 * dp * field[self.slice_index, level, ...]
        
        return partial_column_field
    
    def get_tropopause_pressure(self, surface_pressure_external=None):
        t_idx = self.slice_index
        hyai = self.ref['hyai'][:]
        hybi = self.ref['hybi'][:]
        surface_pressure = self.ref["ps"][t_idx, ...]
        tropopause_layer_index = self.ref["tropopause_layer_index"][t_idx, ...]
        p_interfaces = self.get_pressures_interfaces()
        dest_shape = (self.weights.shape[1], )
        p_tropo = np.zeros(dest_shape, dtype=np.float32)
        
        for pix_idx in range(self.weights.shape[1]):
            if surface_pressure_external is not None:
                ps = surface_pressure_external.flat[pix_idx]
            else:
                ps = 0.0
                for i in range(4):
                    ps += (self.weights[i, pix_idx] * 
                            surface_pressure[self.spatial_index_lat[i, pix_idx], 
                                             self.spatial_index_lon[i, pix_idx]])
                    
            for i in range(4):
                idx = tropopause_layer_index[self.spatial_index_lat[i, pix_idx], 
                                             self.spatial_index_lon[i, pix_idx]] + 1 # top of layer
                
                p_tropo[pix_idx] += self.weights[i, pix_idx] * (hyai[idx] + ps * hybi[idx])
        
        p_tropo = p_tropo.reshape(self.final_output_shape[1:])
        return p_tropo


    def get_temperature(self, surface_pressure_external=None):
        t_idx = self.slice_index
        p_interfaces = self.get_pressures_interfaces()
        field = self.ref["t"][t_idx, ...]
        surface_pressure = self.ref["ps"][t_idx, ...]
        hyam = self.ref['hyam'][:]
        hybm = self.ref['hybm'][:]
        
        dest_shape = (field.shape[0], self.weights.shape[1])
        result_field = np.zeros(dest_shape, dtype=np.float32)
        result_pressure = np.zeros(dest_shape, dtype=np.float32)
       
        result_field, result_pressure = calc_field(self.weights, self.spatial_index_lat, self.spatial_index_lon,
                                                        surface_pressure_external, surface_pressure, field,
                                                        result_field, result_pressure, hyam, hybm)
        
        result_field = result_field.reshape(self.final_output_shape)
        result_pressure = result_pressure.reshape(self.final_output_shape)
        
        return result_field, result_pressure
        
    def get_profiles(self, surface_pressure_external=None):
        t_idx = self.slice_index
        
        p_interfaces = self.get_pressures_interfaces()
        field = self.ref[self.species][t_idx, ...]
        surface_pressure = self.ref["ps"][t_idx, ...]
        hyai = self.ref['hyai'][:]
        hybi = self.ref['hybi'][:]
        
        dest_shape = (field.shape[0], self.weights.shape[1])
        result_field = np.zeros(dest_shape, dtype=np.float32)
        pressure_shape = (field.shape[0]+1, self.weights.shape[1])
        result_pressure = np.zeros(pressure_shape, dtype=np.float32)

        result_field, result_pressure = calc_field(self.weights, self.spatial_index_lat, self.spatial_index_lon,
                                                        surface_pressure_external, surface_pressure, field,
                                                        result_field, result_pressure, hyai, hybi)

        result_field = result_field.reshape(self.final_output_shape)
        pressure_shape = list(self.final_output_shape)
        pressure_shape[0] += 1
        result_pressure = result_pressure.reshape(tuple(pressure_shape))
        
        return result_field, result_pressure
    
def extract_orbit(species:str='no2', ctm:str=None,
        l2_file:str=None, use_TM5_pressure:bool=False, verbose:int=0, 
        **kwargs):
    
    if not os.access(l2_file, os.O_RDWR):
        print(f"""Error when opening '{os.path.basename(l2_file)}' in append mode. 
We need write permission to add the model profiles to the level 2 file.""", file=sys.stderr)
        return
    
    ctmobj = CTM(ctm, species)
    ref = netCDF4.Dataset(l2_file, 'a')
    with ref, ctmobj:
        tstart = datetime.datetime.strptime(ref['/S5P'].time_coverage_start[0:19], '%Y-%m-%dT%H:%M:%S')
        tend = datetime.datetime.strptime(ref['/S5P'].time_coverage_end[0:19], '%Y-%m-%dT%H:%M:%S')
        time = tstart + (tend-tstart)/2
        
        if verbose > 0:
            print("Reading L2 data", file=sys.stderr)
            
        latitudes = ref['/S5P/latitude'][:]
        longitudes = ref['/S5P/longitude'][:]
        if use_TM5_pressure:
            pressures = None
        else:
            pressures = ref['/S5P/surface_pressure'][:]
            
        try:
            ctmobj.find_slice(time)
        except Exception as err:
            print(err, file=sys.stderr)
            sys.exit(1)
        
        if verbose > 0:
            print("Calculating weights", file=sys.stderr)
        ctmobj.find_indices_weights(latitudes, longitudes)
        
        if verbose > 0:
            print("Retrieving profiles", file=sys.stderr)
        result_field, result_pressure = ctmobj.get_profiles(surface_pressure_external=pressures)
        
        if verbose > 1:
            print(f"""NO2 dimensions: {result_field.shape}
pressure bounds dimensions: {result_pressure.shape}""")
            print("Writing output", file=sys.stderr)

        name_map = {'no2': 'nitrogen_dioxide', 'so2': 'sulfur_dioxide', 'hcho': 'formaldehyde'}
        grp = ref['/S5P']
        vname = f"{species}_vmr"
        try:
            var = grp.createVariable(vname, np.float32,
                                    dimensions=('y', 'x', 'layer'),
                                    zlib=True, fletcher32=True)
        except RuntimeError:
            var = grp[vname]
            
        var[:] = result_field.transpose((1,2,0))
        var.units = "1"
        var.long_name = f"TM5-MP a-priori profile of mixing ratios of {species.upper()} co-located with the observations"
        var.standard_name = f"mole_fraction_of_{name_map[species]}_in_air" 
        var.coordinates = "/SP/longitude /SP/latitude"
        if use_TM5_pressure:
            var.ancillary_variables = "/SP/tm5_constant_a /SP/tm5_constant_b /SP/tm5_tropopause_layer_index /SP/TM5_surface_pressure"
        else:
            var.ancillary_variables = "/SP/tm5_constant_a /SP/tm5_constant_b /SP/tm5_tropopause_layer_index /SP/surface_pressure"
        
        if use_TM5_pressure:
            try:
                var = grp.createVariable("TM5_surface_pressure", np.float32,
                                    dimensions=('time', 'y', 'x'),
                                    zlib=True, fletcher32=True)
            except RuntimeError:
                var = grp["TM5_surface_pressure"]
            var[:] = result_pressure[0, ...]
            var.units = "Pa"
            var.long_name = f"Surface pressure used to calculate pressure grid for {vname} profiles"
            var.standard_name = 'surface_air_pressure'
            var.coordinates = "/S5P/longitude /S5P/latitude"
        
        if verbose > 0:
            print("Extracting temperatures", file=sys.stderr)
        result_temperature, result_pressure_mid = ctmobj.get_temperature()
        if verbose > 1:
            print(f"""temperature dimensions: {result_temperature.shape}
mid pres dimensions: {result_pressure_mid.shape}""", file=sys.stderr)
        if verbose > 0:
            print("Writing temperatures", file=sys.stderr)
        vname = "temperature"
        try:
            var = grp.createVariable(vname, np.float32,
                                dimensions=('y', 'x', 'layer'),
                                zlib=True, fletcher32=True)
        except RuntimeError:
            var = grp[vname]
        var[:] = result_temperature.transpose((1,2,0))
        var.units = "K"
        var.long_name = "TM5-MP temperature profile"
        var.standard_name = "air_temperature"
        var.coordinates = "/S5P/longitude /S5P/latitude"
        if use_TM5_pressure:
            var.ancillary_variables = "/S5P/tm5_constant_a /S5P/tm5_constant_b /S5P/tm5_tropopause_layer_index /S5P/TM5_surface_pressure"
        else:
            var.ancillary_variables = "/S5P/tm5_constant_a /S5P/tm5_constant_b /S5P/tm5_tropopause_layer_index /S5P/surface_pressure"

